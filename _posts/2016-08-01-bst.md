---
layout: post
title: Binary Search Tree
---

### Validate Binary Search Tree
Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows:

* The left subtree of a node contains only nodes with keys less than the node's key.
* The right subtree of a node contains only nodes with keys greater than the node's key.
* Both the left and right subtrees must also be binary search trees.

Example 1:
{% highlight python %}
    2
   / \
  1   3
{% endhighlight %}
Binary tree [2,1,3], return true.

Example 2:
{% highlight python %}
    1
   / \
  2   3
{% endhighlight %}
Binary tree [1,2,3], return false.

**Analysis:**

1. DFS is the key.
2. How to update the min and max boundary is also important.

**Code:**
{% highlight python %}
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def isValidBST(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        themax = sys.maxsize
        themin = -sys.maxsize-1
        
        return self.is_valid(root, themin, themax)
        
    def is_valid(self, node, themin, themax):
        if node == None:
            return True
        if node.val <= themin or node.val >= themax:
            return False
        
        return self.is_valid(node.left, themin, node.val) and \
            self.is_valid(node.right, node.val, themax)
{% endhighlight %}


### Convert Sorted Array to Binary Search Tree
Given an array where elements are sorted in ascending order, convert it to a height balanced BST.

**Code:**
{% highlight python %}
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def sortedArrayToBST(self, nums):
        """
        :type nums: List[int]
        :rtype: TreeNode
        """
        return self.trees(nums, 0, len(nums))
        
    def trees(self, nums, start, end):
        if start == end:
            return None
        
        mid = (start+end)//2
        l = self.trees(nums, start, mid)
        r = self.trees(nums, mid+1, end)
        root = TreeNode(nums[mid])
        root.left = l
        root.right = r
        return root
{% endhighlight %}


### Convert Sorted List to Binary Search Tree
Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.

**Code:**
{% highlight python %}
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def sortedListToBST(self, head):
        """
        :type head: ListNode
        :rtype: TreeNode
        """
        if not head:
            return
        if not head.next:
            return TreeNode(head.val)
        
        prev = None
        slow = fast = head
        while fast and fast.next:
            fast = fast.next.next
            prev = slow
            slow = slow.next
        
        prev.next = None
        tmp = slow
        
        root = TreeNode(tmp.val)
        root.left = self.sortedListToBST(head)
        root.right = self.sortedListToBST(tmp.next)
        return root
{% endhighlight %}


### Unique Binary Search Trees
Given n, how many structurally unique BST's (binary search trees) that store values 1...n?

For example, Given n = 3, there are a total of 5 unique BST's.

{% highlight python %}
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
{% endhighlight %}

**Analysis:**

1. Use dynamic programming.
2. Given a sequence 1…n, to construct a Binary Search Tree (BST) out of the sequence, we could enumerate each number i in the sequence, and use the number as the root, naturally, the subsequence 1…(i-1) on its left side would lay on the left branch of the root, and similarly the right subsequence (i+1)…n lay on the right branch of the root. We then can construct the subtree from the subsequence recursively. Through the above approach, we could ensure that the BST that we construct are all unique, since they have unique roots.
3. Important relationships:
    * G(n) = F(1, n) + F(2, n) + ... + F(n, n); G(n) stands for the number of unique BST of given number n, F(i, n) stands for the number of unique BST with i as the root.
    * F(i, n) = G(i-1) * G(n-i), 1 <= i <= n
    * G(n) = G(0) * G(n-1) + G(1) * G(n-2) + … + G(n-1) * G(0)

**Code:**
{% highlight python %}
class Solution(object):
    def numTrees(self, n):
        """
        :type n: int
        :rtype: int
        """
        g = [0]*(n+1)
        g[0] = g[1] = 1
        
        for i in range(2, n+1):
            for j in range(1, i+1):
                g[i] += g[j-1]*g[i-j]
        
        return g[-1]
{% endhighlight %}


### Unique Binary Search Trees II
Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1...n.

For example, Given n = 3, your program should return all 5 unique BST's shown below.

{% highlight python %}
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
{% endhighlight %}

**Analysis:**

1. This question is essentially the same as the previous one.
2. Use DFS to construct trees.

**Code:**
{% highlight python %}
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def generateTrees(self, n):
        """
        :type n: int
        :rtype: List[TreeNode]
        """
        if n == 0:
            return []
        return self.dfs(1, n+1)
        
    def dfs(self, start, end):
        if start == end:
            return [None]
        result = []
        for i in range(start, end):
            lefts = self.dfs(start, i)
            rights = self.dfs(i+1, end)
            
            for l in lefts:
                for r in rights:
                    node = TreeNode(i)
                    node.left, node.right  = l, r
                    result.append(node)
        return result
{% endhighlight %}