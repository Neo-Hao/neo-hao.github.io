---
layout: post
title: Stack
---

### Leetcode Question 224

Implement a basic calculator to evaluate a simple expression string. The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces. You may assume that the given expression is always valid.

Some examples:
{% highlight python %}
"1 + 1" = 2
" 2-1 + 2 " = 3
"(1+(4+5+2)-3)+(6+8)" = 23
{% endhighlight %}

**Analysis:**

1. There is the scenearios when more than one char composing one integer. This scenario needs to be specially handled.
2. Two stack strategy: one stack holds only number, while the other holds brackets and operators.
3. Two other temporary stacks are also in need for correcting the order, and preparing for calculation.

**Code:**

{% highlight python %}
class Solution(object):
    def calculate(self, s):
        """
        :type s: str
        :rtype: int
        """
        nums, signs = [], []
        num = ''
        
        for i in range(len(s)):
            if s[i].isdigit():
                num = num + s[i]
            else:
                if num != '':
                    nums.append(int(num))
                    num = ''
                if s[i] == ')':
                    # pop
                    sign = signs.pop()
                    tmp_nums, tmp_signs = [], []
                    while sign != '(':
                        tmp_nums.append(nums.pop())
                        tmp_signs.append(sign)
                        sign = signs.pop()
                    tmp_nums.append(nums.pop())
                    # calculate
                    val = self.calc(tmp_nums, tmp_signs)
                    nums.append(val)
                elif not s[i].isdigit() and not s[i].isspace():
                    signs.append(s[i])
        if num != '':
            nums.append(int(num))
        
        tmp_nums, tmp_signs = [], []
        while signs:
            tmp_nums.append(nums.pop())
            tmp_signs.append(signs.pop())
        tmp_nums.append(nums.pop())
        
        return self.calc(tmp_nums, tmp_signs)
    
    def calc(self, nums, signs):
        while signs:
            l, r = nums.pop(), nums.pop()
            sign = signs.pop()
            if sign == '+':
                nums.append(l+r)
            else:
                nums.append(l-r)
        result = nums.pop()
        return result
{% endhighlight %}


### Leetcode Question 227
Implement a basic calculator to evaluate a simple expression string. The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero. You may assume that the given expression is always valid.

Some examples:
{% highlight python %}
"3+2*2" = 7
" 3/2 " = 1
" 3+5 / 2 " = 5
{% endhighlight %}

** Analysis:**

1. Using only one stack is not enough for the job. Except for the stack, use two variables to hold the number and sign.
2. If the previous sign indicates multiplication or division, do the calculation and append the result to the stack. Otherwise, simply append the numbers. 
3. The sign is not updated until a new sign is encountered.
4. The calculation doesn't only happen when the sign is updated, but also at the end of the string.

**Code:**
{% highlight python %}
class Solution(object):
    def calculate(self, s):
        stack, num, sign = [], 0, "+"
        for i in range(len(s)):
            if s[i].isdigit():
                num = num*10+int(s[i])
            if (not s[i].isdigit() and not s[i].isspace()) or i == len(s)-1:
                if sign == "-":
                    stack.append(-num)
                elif sign == "+":
                    stack.append(num)
                elif sign == "*":
                    stack.append(stack.pop()*num)
                else:
                    tmp = stack.pop()
                    # stack.append(tmp//num)
                    if tmp//num < 0 and tmp%num != 0:
                        stack.append(tmp//num+1)
                    else:
                        stack.append(tmp//num)
                sign = s[i]
                num = 0
        return sum(stack)
{% endhighlight %}


### Leetcode Question 71
Given an absolute path for a file (Unix-style), simplify it. For example,

{% highlight python %}
path = "/home/", => "/home"
path = "/a/./b/../../c/", => "/c"
{% endhighlight %}

**Analysis:**

1. When there is the pattern such that the occurance of A will erase the occurance of B, consider using a stack.

**Code:**

{% highlight python %}
class Solution(object):
    def simplifyPath(self, path):
        places = [p for p in path.split("/") if p!="." and p!=""]
        stack = []
        for p in places:
            if p == "..":
                if len(stack) > 0:
                    stack.pop()
            else:
                stack.append(p)
        return "/" + "/".join(stack)
{% endhighlight %}


### Verify Preorder Serialization of a Binary Tree
One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as #.

{% highlight python %}
     _9_
    /   \
   3     2
  / \   / \
 4   1  #  6
/ \ / \   / \
# # # #   # #
{% endhighlight %}

For example, the above binary tree can be serialized to the string "9,3,4,#,#,1,#,#,2,#,6,#,#", where # represents a null node.

Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.

Each comma separated value in the string must be either an integer or a character '#' representing null pointer.

You may assume that the input format is always valid, for example it could never contain two consecutive commas such as "1,,3".

Example 1: "9,3,4,#,#,1,#,#,2,#,6,#,#", Return true

Example 2: "1,#", Return false

Example 3: "9,#,#,1", Return false

**Analysis:**

1. The key here is, when you see two consecutive "#" characters on stack, pop both of them and replace the topmost element on the stack with "#".
2. If the string is valid, there would be only one # left in the stack at last.

**Code:**

{% highlight python %}
class Solution(object):
    def isValidSerialization(self, preorder):
        """
        :type preorder: str
        :rtype: bool
        """
        preorder = preorder.split(',')
        
        stack = []
        for i in preorder:
            stack.append(i)
            while self.twohash(stack):
                stack.pop()
                stack.pop()
                stack.pop()
                stack.append('#')
        
        if len(stack) == 1 and stack[-1] == '#':
            return True
        return False
    
    def twohash(self, stack):
        if len(stack) < 3:
            return False
        if stack[-1] == stack[-2] == '#' and stack[-3].isdigit():
            return True
{% endhighlight %}