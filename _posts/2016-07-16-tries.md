---
layout: post
title: Trie (Prefix Tree)
---

### When and how to use tries

1. When there are many words or character strings, and there is also a heavy searching task, tries will come very handy in such a case.
2. A good way to implement tries is shown as the following. The basic idea is to use embedded dictionaries.

{% highlight python %}
trie = {}
for word in words:
    t = trie
    for char in word:
        if char not in t:
            t[char] = {}
        t = t[char]
    t['#'] = '#'
{% endhighlight %}


### Leetcode Question 219
Implement a trie with insert, search, and startsWith methods.

Analytics:

1. A trie is also called radix tree or prefix tree
2. A trie is an ordered tree data structure that is used to store a dynamic set or associative array where the keys are usually strings.
3. Trie is good for searching tasks, especially prefix searching tasks.

![Trie](https://upload.wikimedia.org/wikipedia/commons/b/be/Trie_example.svg=300x)

Code:
{% highlight python %}
class TrieNode(object):
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.end = False
        self.children = {}
        

class Trie(object):

    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        """
        Inserts a word into the trie.
        :type word: str
        :rtype: void
        """
        node= self.root
        for i in word:
            if node.children.get(i, -1) == -1:
                node.children[i] = TrieNode()
            node = node.children[i]
        node.end = True

    def search(self, word):
        """
        Returns if the word is in the trie.
        :type word: str
        :rtype: bool
        """
        node = self.root
        for i in word:
            if node.children.get(i, -1) == -1:
                return False
            node = node.children[i]
        return node.end

    def startsWith(self, prefix):
        """
        Returns if there is any word in the trie
        that starts with the given prefix.
        :type prefix: str
        :rtype: bool
        """
        node = self.root
        for i in prefix:
            if node.children.get(i, -1) == -1:
                return False
            node = node.children[i]
        
        return True
{% endhighlight %}


### Leetcode Question 211
Design a data structure that supports the following two operations:

{% highlight python %}
void addWord(word)
bool search(word)
{% endhighlight %}

search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.

For example:

{% highlight python %}
addWord("bad")
addWord("dad")
addWord("mad")
search("pad") -> false
search("bad") -> true
search(".ad") -> true
search("b..") -> true
{% endhighlight %}

Note:
You may assume that all words are consist of lowercase letters a-z.

Analytics:

1. Trie is good for heavy insertion and search tasks.
2. The only difficult part is to deal with '.'. When a '.' is encountered, use DFS. When a normal char is encountered, use trie search.

Code:

{% highlight python %}
class Trie_node(object):
    def __init__(self):
        """
        initialize your data structure here.
        """
        self.end = False
        self.children = {}

class WordDictionary(object):
    def __init__(self):
        """
        initialize your data structure here.
        """
        self.root = Trie_node()

    def addWord(self, word):
        """
        Adds a word into the data structure.
        :type word: str
        :rtype: void
        """
        node = self.root
        for i in word:
            if node.children.get(i, -1) == -1:
                node.children[i] = Trie_node()
            node = node.children[i]
        node.end = True

    def search(self, word):
        """
        Returns if the word is in the data structure. A word could
        contain the dot character '.' to represent any one letter.
        :type word: str
        :rtype: bool
        """
        return self.search_helper(word, self.root)
    
    def search_helper(self, word, node):
        for i in range(len(word)):
            if word[i] == '.':
                for j in node.children.keys():
                    if self.search_helper(word[i+1:], node.children[j]):
                        return True
                return False
            elif node.children.get(word[i], -1) == -1:
                return False
            node = node.children[word[i]]
        return node.end
{% endhighlight %}


### Leetcode 212
Given a 2D board and a list of words from the dictionary, find all words in the board.

Each word must be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.

For example, Given words = ["oath","pea","eat","rain"] and board =
{% highlight python %}
[
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]
{% endhighlight %}
Return ["eat","oath"].

Analysis:

1. When there are multiple words (strings) and there is a need to search through, the usage of a trie is very handy.
2. The solution to this problem is a combination of trie and dfs.

Code:
{% highlight python %}
class Solution(object):
    def findWords(self, board, words):
        """
        :type board: List[List[str]]
        :type words: List[str]
        :rtype: List[str]
        """
        trie = {}
        for word in words:
            t = trie
            for char in word:
                if char not in t:
                    t[char] = {}
                t = t[char]
            t['#'] = '#'
        res = []
        for i in range(len(board)):
            for j in range(len(board[0])):
                self.dfs(board, i, j, trie, '', res)
        return list(set(res))
        
    def dfs(self, board, i, j, trie, path, res):
        if '#' in trie:
            res.append(path)
        if i<0 or i>=len(board) or \
            j<0 or j>=len(board[0]) or \
            board[i][j] not in trie:
            return
        
        tmp = board[i][j]
        board[i][j] = -1
        self.dfs(board, i+1, j, trie[tmp], path+tmp, res)
        self.dfs(board, i, j+1, trie[tmp], path+tmp, res)
        self.dfs(board, i-1, j, trie[tmp], path+tmp, res)
        self.dfs(board, i, j-1, trie[tmp], path+tmp, res)
        board[i][j] = tmp
{% endhighlight %}