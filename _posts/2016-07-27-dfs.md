---
layout: post
title: Depth First Search
---

### Basics of DFS

1. DFS for most problems requires two things: a) the ending conditions b) the recursions.
2. It is common for DFS that when one scenario safisfies the condition, then return true, and otherwise false. In such scenarios, make the DFS function return a boolean value. If one of the callings of the DFS function returns true, then the main function returns true. Otherwise return false at the very end of the DFS function.


### Leetcode Question 77
Given two integers n and k, return all possible combinations of k numbers out of 1 ... n. For example, If n = 4 and k = 2, a solution is:
{% highlight python %}
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
{% endhighlight %}

**Analysis:**

1. Combination problem is kind of different from most DFS cases, because [1,2] and [2,1] are considered the same.
2. To avoid adding repetitions to the result, only add items that appear later than the current item in the list. Use two pointer strategy to achieve this.

**Code:**
{% highlight python %}
class Solution(object):
    def combine(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: List[List[int]]
        """
        nums = [i for i in range(1, n+1)]
        result = []
        self.comb(nums, [], 0, n, k, result)
        return result
    
    def comb(self, nums, path, start, end, k, result):
        if k == 0:
            result.append(path)
            return
        
        for i in range(start, end):
            self.comb(nums, path + [nums[i]], i+1, end, k-1, result)
{% endhighlight %}


### Leetcode Question 306
Additive number is a string whose digits can form additive sequence. A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.

* Example 1: "112358" is an additive number because the digits can form an additive sequence: 1, 1, 2, 3, 5, 8.
    - 1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8
* Example 2: "199100199" is also an additive number, the additive sequence is: 1, 99, 100, 199.
    - 1 + 99 = 100, 99 + 100 = 199

Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid. Given a string containing only digits '0'-'9', write a function to determine if it's an additive number.

**Analysis:**

1. It is pretty common for DFS that when one scenario safisfy the condition, then return true, and otherwise false.
2. In such scenarios, make the DFS function return a boolean value. If one of the callings of the DFS function returns true, then the main function returns true. Otherwise return false at the very end of the DFS function.
3. It's okay for the upper bound to go to len(num)//2+1, but not okay to go down by 1.

**Code:**

{% highlight python %}
class Solution(object):
    def isAdditiveNumber(self, num):
        """
        :type num: str
        :rtype: bool
        """
        if len(num) < 3:
            return False  
        result = False
        for i in range(1, len(num)//2+1):
            if num[0] == '0' and i > 1:
                return False
            first = num[:i]
            for j in range(i+1, len(num)//3*2+1):
                if num[i] == '0' and j - i > 1:
                    break
                second = num[i:j]
                if self.check(first, second, j, num):
                    return True
        return False
    
    def check(self, first, second, j, num):
        third = str(int(first)+int(second))
        if len(third) == len(num[j:]) and third == num[j:]:
            return True
        if len(third) > len(num[j:]) or third != num[j:(j + len(third))]:
            return False
        first = second
        second = third
        return self.check(first, second, j+len(third), num)
{% endhighlight %}


### Leetcode Question 219
Given a string containing only digits, restore it by returning all possible valid IP address combinations. Valid IP requires:

1. There must be three dots, and four digit blocks.
2. A digit block can not start with 0 if there are more than 1 digits.
3. The integer composed of a digit block can not be bigger than 255.

For example: Given "25525511135",

return ["255.255.11.135", "255.255.111.35"]. (Order does not matter)

**Analysis:**

1. DFS for most problems requires two things: a) the ending conditions b) the recursions.

Code:
{% highlight python %}
class Solution(object):
    def restoreIpAddresses(self, s):
        """
        :type s: str
        :rtype: List[str]
        """
        count = 0
        result = []
        self.add_dot(s, '', 0, result)
        return result
    
    def add_dot(self, s, path, count, result):
        if count == 3:
            if len(s) == 1:
                result.append(path + s)
            elif len(s) > 1 and len(s) <= 3 and s[0] != '0' and int(s) <= 255:
                result.append(path + s)
            else:
                return
        
        c = 1
        while c <=3 and c < len(s):
            if len(s[:c]) == 1:
                self.add_dot(s[c:], path + s[:c] + '.', count+1, result)
            elif s[0] != '0' and int(s[:c]) <= 255:
                self.add_dot(s[c:], path + s[:c] + '.', count+1, result)
            c += 1
{% endhighlight %}